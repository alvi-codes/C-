class Solution {
public:

    bool do_dfs(int i, int j, vector<vector<char>>& board, set<pair<int, int>>& indexes) {
        // If out of bounds, return true
        if (i >= board.size() || i < 0 || j >= board[0].size() || j < 0) {
            return true;
        }
        
        // If this cell is an 'O' and is on the boundary, return false
        if ( (i == 0 || i == board.size() - 1 || j == 0 || j == board[0].size() - 1) && board[i][j] == 'O') {
            return false;
        }
        
        // If this cell is an 'X' or already visited, return true
        if (board[i][j] == 'X' || indexes.find(make_pair(i, j)) != indexes.end()) {
            return true;
        }
        
        // Add the current cell to the visited set
        indexes.insert(make_pair(i, j));
        
        // Check all four directions
        return do_dfs(i + 1, j, board, indexes) &&
               do_dfs(i - 1, j, board, indexes) &&
               do_dfs(i, j + 1, board, indexes) &&
               do_dfs(i, j - 1, board, indexes);
    }

    void make_x(set<pair<int, int>>& indexes, vector<vector<char>>& board) {
        for(auto it : indexes) {
            board[it.first][it.second] = 'X';
        }
    }

    void solve(vector<vector<char>>& board) {
        int rows = board.size();
        if (rows == 0) {
            return; // Added this check in case of an empty board
        }
        int cols = board[0].size();

        set<pair<int, int>> indexes;

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {

                if (board[i][j] == 'O' && indexes.find(make_pair(i, j)) == indexes.end()) { 
                    // Check if the cell hasn't been visited
                    if (do_dfs(i, j, board, indexes)) {
                        make_x(indexes, board);
                    }
                    indexes.clear();
                }
                
            }
        }   
    }
};
